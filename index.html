<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OgreDocs</title>
    
    <link rel="stylesheet" type="text/css" href="http://documentup.com/stylesheets/themes/v1.css">
    
    

    
      <!-- Google Analytics -->
      <script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-11943276-8']);
        _gaq.push(['_trackPageview']);

        (function() {
          var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
          ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

      </script>
    

    <!-- Typekit -->
    
      <script type="text/javascript">
        (function() {
          var config = {
            kitId: 'hjp0pft',
            scriptTimeout: 3000
          };
          var h=document.getElementsByTagName("html")[0];h.className+=" wf-loading";var t=setTimeout(function(){h.className=h.className.replace(/( |^)wf-loading( |$)/g,"");h.className+=" wf-inactive"},config.scriptTimeout);var tk=document.createElement("script");tk.src='//use.typekit.net/'+config.kitId+'.js';tk.type="text/javascript";tk.async="true";tk.onload=tk.onreadystatechange=function(){var a=this.readyState;if(a&&a!="complete"&&a!="loaded")return;clearTimeout(t);try{Typekit.load(config)}catch(b){}};var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(tk,s)
        })();
      </script>
    
  </head>
  <body><div id="container">
  <div id="nav">
    
      <div id="header">
        <a href="#" id="logo">OgreDocs</a>
      </div>
    
    <ul id="sections">
      
        <li>
          <a href="#introduction">Introduction</a>
          
        </li>
      
        <li>
          <a href="#getting-started">Getting started</a>
          
            <ul>
              
                <li>
                  <a href="#getting-started/the-tinkerpop-stack">The Tinkerpop stack</a>
                </li>
              
                <li>
                  <a href="#getting-started/leiningen">leiningen</a>
                </li>
              
                <li>
                  <a href="#getting-started/the-tinkergraph">The TinkerGraph</a>
                </li>
              
                <li>
                  <a href="#getting-started/so-what-does-ogre-actually-do">So what does Ogre actually do?</a>
                </li>
              
                <li>
                  <a href="#getting-started/using-ogredocs">Using OgreDocs</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#building-queries">Building queries</a>
          
        </li>
      
        <li>
          <a href="#traversal">Traversal</a>
          
            <ul>
              
                <li>
                  <a href="#traversal/out">out / --&gt;</a>
                </li>
              
                <li>
                  <a href="#traversal/out-edges-e">out-edges / --E&gt;</a>
                </li>
              
                <li>
                  <a href="#traversal/out-vertex">out-vertex</a>
                </li>
              
                <li>
                  <a href="#traversal/in">in / &lt;--</a>
                </li>
              
                <li>
                  <a href="#traversal/in-edges-e">in-edges / &lt;E--</a>
                </li>
              
                <li>
                  <a href="#traversal/in-vertex">in-vertex</a>
                </li>
              
                <li>
                  <a href="#traversal/both">both / &lt;-&gt;</a>
                </li>
              
                <li>
                  <a href="#traversal/both-edges-e">both-edges / `&lt;E&gt;`</a>
                </li>
              
                <li>
                  <a href="#traversal/both-vertices">both-vertices</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#map">Map</a>
          
            <ul>
              
                <li>
                  <a href="#map/id">id</a>
                </li>
              
                <li>
                  <a href="#map/property">property</a>
                </li>
              
                <li>
                  <a href="#map/label">label</a>
                </li>
              
                <li>
                  <a href="#map/map">map</a>
                </li>
              
                <li>
                  <a href="#map/path">path</a>
                </li>
              
                <li>
                  <a href="#map/transform">transform</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#executors">Executors</a>
          
            <ul>
              
                <li>
                  <a href="#executors/to-list">to-list!</a>
                </li>
              
                <li>
                  <a href="#executors/into-vec">into-vec!</a>
                </li>
              
                <li>
                  <a href="#executors/into-set">into-set!</a>
                </li>
              
                <li>
                  <a href="#executors/first-of">first-of!</a>
                </li>
              
                <li>
                  <a href="#executors/first-into-vec">first-into-vec!</a>
                </li>
              
                <li>
                  <a href="#executors/first-into-set">first-into-set!</a>
                </li>
              
                <li>
                  <a href="#executors/first-into-map">first-into-map!</a>
                </li>
              
                <li>
                  <a href="#executors/all-into-vecs">all-into-vecs!</a>
                </li>
              
                <li>
                  <a href="#executors/all-into-sets">all-into-sets!</a>
                </li>
              
                <li>
                  <a href="#executors/all-into-maps">all-into-maps!</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#reduce">Reduce</a>
          
            <ul>
              
                <li>
                  <a href="#reduce/order">order</a>
                </li>
              
                <li>
                  <a href="#reduce/gather">gather</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#filter">Filter</a>
          
            <ul>
              
                <li>
                  <a href="#filter/range">range</a>
                </li>
              
                <li>
                  <a href="#filter/dedup">dedup</a>
                </li>
              
                <li>
                  <a href="#filter/except">except</a>
                </li>
              
                <li>
                  <a href="#filter/filter">filter</a>
                </li>
              
                <li>
                  <a href="#filter/has">has</a>
                </li>
              
                <li>
                  <a href="#filter/has-not">has-not</a>
                </li>
              
                <li>
                  <a href="#filter/interval">interval</a>
                </li>
              
                <li>
                  <a href="#filter/random">random</a>
                </li>
              
                <li>
                  <a href="#filter/retain">retain</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#annotations">Annotations</a>
          
            <ul>
              
                <li>
                  <a href="#annotations/back">back</a>
                </li>
              
                <li>
                  <a href="#annotations/as-back-to">as/back-to</a>
                </li>
              
                <li>
                  <a href="#annotations/select">select</a>
                </li>
              
                <li>
                  <a href="#annotations/select-only">select-only</a>
                </li>
              
                <li>
                  <a href="#annotations/loop">loop</a>
                </li>
              
                <li>
                  <a href="#annotations/loop-to">loop-to</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#side-effect">Side Effect</a>
          
            <ul>
              
                <li>
                  <a href="#side-effect/get-grouped-by">get-grouped-by</a>
                </li>
              
                <li>
                  <a href="#side-effect/get-group-count">get-group-count</a>
                </li>
              
                <li>
                  <a href="#side-effect/get-table">get-table</a>
                </li>
              
                <li>
                  <a href="#side-effect/get-tree">get-tree</a>
                </li>
              
                <li>
                  <a href="#side-effect/side-effect">side-effect</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#branch">Branch</a>
          
            <ul>
              
                <li>
                  <a href="#branch/copy-split">copy-split</a>
                </li>
              
                <li>
                  <a href="#branch/exhaust-merge">exhaust-merge</a>
                </li>
              
                <li>
                  <a href="#branch/fair-merge">fair-merge</a>
                </li>
              
                <li>
                  <a href="#branch/if-then-else">if-then-else</a>
                </li>
              
                <li>
                  <a href="#branch/memoize">memoize</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#recipes">Recipes</a>
          
            <ul>
              
                <li>
                  <a href="#recipes/duplicate-edges">Duplicate Edges</a>
                </li>
              
                <li>
                  <a href="#recipes/paging-results">Paging Results</a>
                </li>
              
                <li>
                  <a href="#recipes/paths-between-two-vertices">Paths Between Two Vertices</a>
                </li>
              
                <li>
                  <a href="#recipes/reading-from-a-file">Reading From a File</a>
                </li>
              
                <li>
                  <a href="#recipes/sampling">Sampling</a>
                </li>
              
                <li>
                  <a href="#recipes/shortest-path">Shortest Path</a>
                </li>
              
            </ul>
          
        </li>
      
    </ul>
    
    
      <div class="extra twitter">
        <iframe allowtransparency="true" frameborder="0" scrolling="no" style="width:162px; height:20px;" src="https://platform.twitter.com/widgets/follow_button.html?screen_name=zmaril&show_count=false"></iframe>
      </div>
    
  </div>
  <div id="content">
    
    <p><img src="ogre.png" height="200"></img>

</p>
<p><strong>WARNING OgreDocs is still being written.</strong>

</p>
<h2 id='introduction'>Introduction</h2 id='introduction'>
<p><a href="http://github.com/zmaril/ogre">Ogre</a> is a domain specific language
for traversing property graphs in <a href="http://clojure.org/">Clojure</a>. Ogre
wraps <a href="https://github.com/tinkerpop/gremlin/wiki">Gremlin</a>, a library
which enables <a href="http://gremlindocs.com/">all sorts of groovy operations on graphs</a>. 

</p>
<p>The documentation and samples presented here attempt to stay current
with the most current, stable release of Ogre. Please join the
<a href="http://groups.google.com/group/gremlin-users">Gremlin users group</a>
for any Ogre related discussions. Please use the
<a href="https://github.com/zmaril/ogre/issues">Ogre issue page</a> for
specifically reporting bugs and discussing features. For any errors or
corrections with OgreDocs, please use the
<a href="https://github.com/zmaril/ogredocs">OrgeDocs issue page</a>. This page
is a fork of <a href="http://gremlindocs.com/">GremlinDocs</a>.

</p>
<p>Pull requests will be celebrated, scrutinized, and hopefully accepted.
If the pull request is really solid, then I&#39;ll probably <a href="http://felixge.de/2013/03/11/the-pull-request-hack.html">give you commit
access</a> to
Ogre and cross my fingers. 

</p>
<p>Ogre currently powers
<a href="https://github.com/zmaril/archimedes">Archimedes</a>, a Clojure library
for <a href="https://github.com/tinkerpop/blueprints/wiki">Blueprints</a>, and
<a href="https://github.com/zmaril/hermes">Hermes</a>, a Clojure library built on
top of Archimedes for working with
<a href="http://thinkaurelius.github.com/titan/">Titan</a>. Ogre, Archimedes, and
Hermes are all open source projects developed and maintained by
<a href="https://twitter.com/ZackMaril">Zack Maril</a>.

</p>
<hr>
<h2 id='getting-started'>Getting started</h2 id='getting-started'>
<h3 id='getting-started/the-tinkerpop-stack'>The Tinkerpop stack</h3 id='getting-started/the-tinkerpop-stack'>
<p>Before going down the rabbit hole, I offer the briefest of warnings:
the <a href="https://github.com/tinkerpop?tab=members">Tinkerpop folks</a> have
been working on Gremlin,
<a href="https://github.com/tinkerpop/pipes/wiki">Pipes</a>, and
<a href="https://github.com/tinkerpop/blueprints/wiki">Blueprints</a> for a few
years now and the stack has become incredibly intertwined. Ogre and
<a href="https://github.com/zmaril/archimedes">Archimedes</a> try to hide all of
this from you at some hide level, but every abstraction leaks. Your
stack traces will speak of <code>com.tinkerpop.blueprints.Vertex</code> and
<code>com.tinkerpop.gremlin.GremlinPipeline</code>, and there is nothing I can
(well, should) do about it. The Tinkerpop stack is fantastic and
really well done, but I wanted to warn you that the following is just
the tip of the iceberg in terms of what you will need to know what is
really going on when you use Ogre. 

</p>
<p>With that terribly encouraging thought, let&#39;s get started!

</p>
<h3 id='getting-started/leiningen'>leiningen</h3 id='getting-started/leiningen'>
<p>The version scheme for Ogre is as follows:
<code>[Full Gremlin version].[Ogre major version]</code>. Philosophically, the
authors of Gremlin are the ones who will be causing most of the
changes to Ogre. Ogre is a mere wrapper around their work and the
version scheme acknowledges that directly. Thus, the first and current
release is <code>0.2.2.0</code>, meaning that the current release uses Gremlin
<code>0.2.2</code> and has undergone zero major versions itself so far since
release.

</p>
<p>To get started with Ogre, include the following dependency for
leiningen: <code>[zmaril/ogre &quot;0.2.2.0&quot;]</code>.

</p>
<h3 id='getting-started/the-tinkergraph'>The TinkerGraph</h3 id='getting-started/the-tinkergraph'>
<p>Unless otherwise noted, all samples reference <code>ogre.tinkergraph</code> and <code>ogre.core</code>.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">require</span><span class="body"> '[ogre.tinkergraph <span class="keyword">:as</span> g]</span>)</span> 
<span class="list">(<span class="title">require</span><span class="body"> '[ogre.core <span class="keyword">:as</span> q]</span>)</span> 

<span class="list">(<span class="title">g/use-new-tinker-graph</span><span class="body">!</span>)</span></code></pre>
<p><code>g/use-new-tinker-graph!</code> creates the following graph and secretly
squirrels it away
<a href="https://github.com/zmaril/ogre/blob/master/src/ogre/tinkergraph.clj#L10"><em>somewhere</em></a>
(image from
<a href="http://github.com/tinkerpop/blueprints/wiki/Property-Graph-Model">here</a>):

</p>
<p><img src="https://github.com/tinkerpop/blueprints/raw/master/doc/images/graph-example-1.jpg"></img>

</p>
<p>I recommend that you open this image up into a
<a href="https://github.com/tinkerpop/blueprints/raw/master/doc/images/graph-example-1.jpg">new tab</a>.
It will serve as the main reference for the majority of the examples below. 

</p>
<h3 id='getting-started/so-what-does-ogre-actually-do'>So what does Ogre actually do?</h3 id='getting-started/so-what-does-ogre-actually-do'>
<p>At a high level, Ogre let&#39;s you easily ask complex questions about
certain types of graphs and get back answers. That&#39;s really all it
does. 

</p>
<p>At a low level, Ogre is a library that takes in Blueprint Vertices and
Edges and let&#39;s you build up GremlinPipeline objects that ask
questions about those objects in the language of traversals,
transformations, filters, and branching on the graph. Ogre allows you
to annotate various steps of the pipeline to allow for incredibly
useful queries in a few terse lines. Ogre also carefully deals with some of
the side effects that the Gremlin library can perform. 

</p>
<p>At the lowest level, Ogre is probably equivalent to some crazy Turing
machine. Man, I wonder if some poor grad student has ever tried to
write the JVM as a Turing machine. Poor guy. 

</p>
<h3 id='getting-started/using-ogredocs'>Using OgreDocs</h3 id='getting-started/using-ogredocs'>
<p>OgreDocs is organized to be read mostly linearly. That means that you
can probably read it from start to finish and understand what is going
on. That means it starts from the basics, traversals, maps,
conversions, and filters. Then it transitions into the more advanced
topics of annotations, side effects, branching, and recipes. At the
same time, it is meant to serve as a complete reference for anyone
using the library (ctrl+f is your friend). These examples were are
developed at the command line or inside emacs with a REPL, so they are
meant to be run and experimented with.


</p>
<hr>
<h2 id='building-queries'>Building queries</h2 id='building-queries'>
<p>Ogre let&#39;s you build up Gremlin queries from scratch. The main method
for doing this is <code>q/query</code>. Here is a simple query on the
Tinkergraph. It takes in the vertex with id <code>1</code>, finds the vertices
that the starting vertex points out to, and then returns the result in
a vector.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">require</span><span class="body"> '[ogre.tinkergraph <span class="keyword">:as</span> g]</span>)</span> 
<span class="list">(<span class="title">require</span><span class="body"> '[ogre.core <span class="keyword">:as</span> q]</span>)</span> 

<span class="list">(<span class="title">g/use-new-tinker-graph</span><span class="body">!</span>)</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[2]> #&lt;TinkerVertex v[4]> #&lt;TinkerVertex v[3]>]</span></code></pre>
<p>Let&#39;s break this down: 

</p>
<ul>
<li><code>q/query</code> is a macro that is
<a href="https://github.com/zmaril/ogre/blob/master/src/ogre/util.clj#L13">just a combination</a>
of <code>-&gt;</code> and <code>(GremlinPipeline.)</code>. It takes in a single element or a
Collection and creates a new pipeline around them. </li>
<li><code>g/find-by-id</code> is a function that goes and asks the vertex for the
element of id 1. </li>
<li><code>q/--&gt;</code> is a function which adds on an outwards traversal step to
the pipe. This means that the Gremlin query will take all the
vertices it is currently thinking about and then look for all the
vertices that the previous vertices pointed to. </li>
<li><code>q/into-vec!</code> executes the query and returns the results inside of a
vector. Up until this call, the Gremlin query hasn&#39;t actually done
anything yet. Only when a function that ends with a bang is passed
in does anything actually happen beyond just a GremlinPipeline
getting built up. </li>
</ul>
<p>So far so good. But, I wonder, who is the dashing rogue behind
<code>#&lt;TinkerVertex v[2]&gt;</code>?

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         q/into-vec!
         first
         <span class="list">(<span class="body"><span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:name</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;;"vadas"</span></code></pre>
<p><code>q/query</code> isn&#39;t just about running Gremlin queries. Remember,
it&#39;s really just a glorified <code>-&gt;</code> with helper functions. That means we
can stick a <code>first</code> in there to get the first vertex of the vector.
<code>(q/prop :name)</code> takes a property key and returns a function which
takes a vertex and returns the given property. Thus, <code>&quot;vadas&quot;</code> is the
charming face of <code>#&lt;TinkerVertex v[2]&gt;</code>.

</p>
<hr>
<h2 id='traversal'>Traversal</h2 id='traversal'>
<p>Traversal functions allow you to explore around the graph and see how
vertices are connected. 

</p>
<h3 id='traversal/out'>out / --&gt;</h3 id='traversal/out'>
<p><code>--&gt;</code> or <code>out</code> gets the out adjacent vertices (the functions do
exactly the same thing, one just looks cooler). Additionally, labels
can be supplied that makes the graph only traverse edges with those
labels. This also applies to the other traversal functions where it
makes sense (any function that is named with arrows).

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">4</span></span>)</span>
         q/-->
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[5]> #&lt;TinkerVertex v[3]>]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">4</span></span>)</span>
         q/out
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[5]> #&lt;TinkerVertex v[3]>]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">4</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"> <span class="keyword">:created</span></span>)</span>
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[5]> #&lt;TinkerVertex v[3]>]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">4</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"> <span class="keyword">:hates</span></span>)</span>
         q/into-vec!</span>)</span>
<span class="comment">;;[]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">4</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"> <span class="keyword">:created</span> <span class="keyword">:hates</span></span>)</span>
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[5]> #&lt;TinkerVertex v[3]>]</span></code></pre>
<h3 id='traversal/out-edges-e'>out-edges / --E&gt;</h3 id='traversal/out-edges-e'>
<p>Gets the outgoing edges of the vertex.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">4</span></span>)</span>
         q/--E>
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerEdge e[10][4-created->5]> #&lt;TinkerEdge e[11][4-created->3]>]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">4</span></span>)</span>
         q/out-edges
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerEdge e[10][4-created->5]> #&lt;TinkerEdge e[11][4-created->3]>]</span></code></pre>
<h3 id='traversal/out-vertex'>out-vertex</h3 id='traversal/out-vertex'>
<p>Get the outgoing tail vertex of the edge.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">4</span></span>)</span>
         q/--E>
         q/out-vertex
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[4]> #&lt;TinkerVertex v[4]>]</span></code></pre>
<p>Conceptually, this might seem same strange at first. Why does it
return the same vertex twice? The answer lies in the example queries
for <code>--E&gt;</code>. Those queries return two edges. The current query is the
same as the <code>--E&gt;</code> query except we are asking for the <code>out-vertex</code>.
That means, by the time we are asking for the <code>out-vertex</code>, we have
two objects &quot;in the pipeline&quot;. Thus, we get two objects back. 

</p>
<h3 id='traversal/in'>in / &lt;--</h3 id='traversal/in'>
<p>Gets the adjacent vertices to the vertex.

</p>
<pre><code class="clojure">(q/query (g/find-by-id 3)
         q/<span class="tag">&lt;<span class="title">--
</span>         <span class="attribute">q</span>/<span class="attribute">into-vec</span>!)
;;[#&lt;<span class="attribute">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">6</span>]></span>]</code></pre>
<h3 id='traversal/in-edges-e'>in-edges / &lt;E--</h3 id='traversal/in-edges-e'>
<p>Gets the incoming edges of the vertex.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">3</span></span>)</span>
         q/&lt;E--
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerEdge e[9][1-created->3]> </span>
<span class="comment">;; #&lt;TinkerEdge e[11][4-created->3]> </span>
<span class="comment">;; #&lt;TinkerEdge e[12][6-created->3]>]</span></code></pre>
<h3 id='traversal/in-vertex'>in-vertex</h3 id='traversal/in-vertex'>
<p>Get incoming head vertex of the edge.
</p>
<pre><code class="clojure">(q/query (g/find-by-id 3)
         q/<span class="tag">&lt;<span class="title">E--
</span>         <span class="attribute">q</span>/<span class="attribute">in-vertex</span>
         <span class="attribute">q</span>/<span class="attribute">into-vec</span>!)
;;[#&lt;<span class="attribute">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span>]</code></pre>
<h3 id='traversal/both'>both / &lt;-&gt;</h3 id='traversal/both'>
<p>Get both adjacent vertices of the vertex, the in and the out.

</p>
<pre><code class="clojure">(q/query (g/find-by-id 4)
         q/<span class="tag">&lt;<span class="title">-</span>></span>
         q/into-vec!)
;;[#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">5</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span>]</code></pre>
<h3 id='traversal/both-edges-e'>both-edges / <code>&lt;E&gt;</code></h3 id='traversal/both-edges-e'>
<p>Get both incoming and outgoing edges of the vertex.

</p>
<pre><code class="clojure">(q/query (g/find-by-id 4)
         q/<span class="tag">&lt;<span class="title">E</span>></span>
         q/into-vec!)
;;[#<span class="tag">&lt;<span class="title">TinkerEdge</span> <span class="attribute">e</span>[<span class="attribute">8</span>][<span class="attribute">1-knows-</span>></span>4]> 
;; #<span class="tag">&lt;<span class="title">TinkerEdge</span> <span class="attribute">e</span>[<span class="attribute">10</span>][<span class="attribute">4-created-</span>></span>5]> 
;; #<span class="tag">&lt;<span class="title">TinkerEdge</span> <span class="attribute">e</span>[<span class="attribute">11</span>][<span class="attribute">4-created-</span>></span>3]>]</code></pre>
<h3 id='traversal/both-vertices'>both-vertices</h3 id='traversal/both-vertices'>
<p>Get both incoming and outgoing vertices of the edge.
</p>
<pre><code class="clojure">(q/query (g/find-by-id 4)
         q/<span class="tag">&lt;<span class="title">E</span>></span>
         q/both-vertices
         q/into-vec!)
;;[#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span> 
;; #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">5</span>]></span> 
;; #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span>]</code></pre>
<hr>
<h2 id='map'>Map</h2 id='map'>
<p>The following functions are conceptually similar in scope to
<code>clojure.core/map</code> and so are grouped together. They all take in a
function and perform some transformation on it. 

</p>
<h3 id='map/id'>id</h3 id='map/id'>
<p>Gets the unique identifier of the element.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/id
         q/into-vec!</span>)</span>
<span class="comment">;;["1"]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         q/id
         q/into-vec!</span>)</span>
<span class="comment">;;["2" "4" "3"]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/id
         q/-->         
         q/into-vec!</span>)</span>
<span class="comment">;;ClassCastException java.lang.String cannot be cast to  com.tinkerpop.blueprints.Vertex  </span>
<span class="comment">;;com.tinkerpop.gremlin.pipes.transform.VerticesVerticesPipe.processNextStart </span>
<span class="comment">;;(VerticesVerticesPipe.java:37)</span></code></pre>
<h3 id='map/property'>property</h3 id='map/property'>
<p>Get the property value of an element. 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/property</span><span class="body"> <span class="keyword">:name</span></span>)</span>
         q/into-vec!</span>)</span>
<span class="comment">;;["marko"]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         <span class="list">(<span class="title">q/property</span><span class="body"> <span class="keyword">:name</span></span>)</span>
         q/into-vec!</span>)</span>
<span class="comment">;;["vadas" "josh" "lop"]</span></code></pre>
<h3 id='map/label'>label</h3 id='map/label'>
<p>Gets the label of an edge.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/property</span><span class="body"> <span class="keyword">:name</span></span>)</span>
         q/into-vec!</span>)</span>
<span class="comment">;;["marko"]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         <span class="list">(<span class="title">q/property</span><span class="body"> <span class="keyword">:name</span></span>)</span>
         q/into-vec!</span>)</span>
<span class="comment">;;["vadas" "josh" "lop"]</span></code></pre>
<h3 id='map/map'>map</h3 id='map/map'>
<p>Gets the property map of the graph element.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/map
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;HashMap {name=marko, age=29}>]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/map
         q/first-into-map!</span>)</span>
<span class="comment">;;{:name "marko", :age 29}</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         q/map
         q/all-into-maps!</span>)</span>
<span class="comment">;;({:name "vadas", :age 27} {:name "josh", :age 32} {:name "lop", :lang "java"})</span></code></pre>
<p>We now see two new functions in addition to <code>q/map</code>: <code>first-into-map!</code>
and <code>all-into-maps!</code>. As you see, Gremlin doesn&#39;t return Clojure data
structures. The new functions execute the Gremlin query and then call
the correct conversion methods to ensure that you can work with the
returned objects without too much hassle. 

</p>
<h3 id='map/path'>path</h3 id='map/path'>
<p>Gets the path through the pipeline up to this point. If functions are
provided, they are applied round robin to each of the objects in the
path. 

</p>
<pre><code class="clojure">(q/query (g/find-by-id 1)
         q/<span class="tag">&lt;<span class="title">-</span>></span>
         q/<span class="tag">&lt;<span class="title">-</span>></span>
         q/path
         q/all-into-vecs!)
;; ([#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">2</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span>] 
;;  [#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span>] 
;;  [#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">5</span>]></span>] 
;;  [#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span>] 
;;  [#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span>] 
;;  [#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span>] 
;;  [#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">6</span>]></span>])         

(q/query (g/find-by-id 1)
         q/<span class="tag">&lt;<span class="title">-</span>></span>
         q/<span class="tag">&lt;<span class="title">-</span>></span>
         (q/path (q/prop :name))
         q/all-into-vecs!)
;;(["marko" "vadas" "marko"] 
;; ["marko" "josh" "marko"] 
;; ["marko" "josh" "ripple"] 
;; ["marko" "josh" "lop"] 
;; ["marko" "lop" "marko"] 
;; ["marko" "lop" "josh"] 
;; ["marko" "lop" "peter"])

(q/query (g/find-by-id 1)
         q/<span class="tag">&lt;<span class="title">-</span>></span>
         q/<span class="tag">&lt;<span class="title">-</span>></span>
         (q/path (q/prop :name) (fn [v] (count (.getProperty v "name"))))
         q/all-into-vecs!)
;;(["marko" 5 "marko"] 
;; ["marko" 4 "marko"] 
;; ["marko" 4 "ripple"] 
;; ["marko" 4 "lop"] 
;; ["marko" 3 "marko"] 
;; ["marko" 3 "josh"] 
;; ["marko" 3 "peter"])</code></pre>
<p>Note that again we have introduced a new function <code>all-into-vecs!</code>.
This function takes in an ArrayList of ArrayLists and produces a list
of vectors.

</p>
<h3 id='map/transform'>transform</h3 id='map/transform'>
<p>Transform applies a function to each object. 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/transform</span><span class="body"> <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:name</span></span>)</span></span>)</span>
         q/first-of!</span>)</span>
<span class="comment">;;"marko"         </span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
          q/--E>
          q/label
          <span class="list">(<span class="title">q/transform</span><span class="body"> count</span>)</span>
          q/into-vec!</span>)</span>         
<span class="comment">;;[5 5 7]</span></code></pre>
<p><code>first-of!</code> executes the query and gets the first element from the
list. Don&#39;t shoot yourself in the foot.

</p>
<h2 id='executors'>Executors</h2 id='executors'>
<p>Ogre cannot do everything for you. Specifically, it does not figure
out the sorts of Java objects that are returned from some arbitrary
query and convert them automatically into Clojure objects. So, with
that in mind, Ogre includes several functions that execute the
pipeline and then do conversions into Clojure data structures.


</p>
<h3 id='executors/to-list'>to-list!</h3 id='executors/to-list'>
<p>This is the Grand Daddy of all Executors. It calls <code>.toList</code> on the
Gremlin pipeline and gets back the list of Java objects. You probably
don&#39;t want to use this directly. 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         q/to-list!</span>)</span>
<span class="comment">;;#&lt;ArrayList [v[2], v[4], v[3]]></span></code></pre>
<h3 id='executors/into-vec'>into-vec!</h3 id='executors/into-vec'>
<p>Gets the objects and sticks them inside of a vector. 

</p>
<pre><code class="clojure">(q/query (g/find-by-id 1)
         q/-->
         q/into-vec!)
;;[#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">2</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span>]</code></pre>
<h3 id='executors/into-set'>into-set!</h3 id='executors/into-set'>
<p>Gets the objects and sticks them inside of a set. 

</p>
<pre><code class="clojure">(q/query (g/find-by-id 1)
         q/-->         
         q/into-set!)
;;#{#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">2</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span>}</code></pre>
<h3 id='executors/first-of'>first-of!</h3 id='executors/first-of'>
<p>Gets the first object of the returned list. 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/first-of!</span>)</span>
<span class="comment">;;#&lt;TinkerVertex v[1]></span></code></pre>
<h3 id='executors/first-into-vec'>first-into-vec!</h3 id='executors/first-into-vec'>
<p>Gets the first object of the returned list and puts it into a vector. 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/property</span><span class="body"> <span class="keyword">:name</span></span>)</span>
         q/path
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;ArrayList [v[1], marko]>]         </span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/property</span><span class="body"> <span class="keyword">:name</span></span>)</span>
         q/path
         q/first-into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[1]> "marko"]</span></code></pre>
<h3 id='executors/first-into-set'>first-into-set!</h3 id='executors/first-into-set'>
<p>Gets the first object of the returned list and puts it into a set. 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         q/id
         q/gather
         q/first-into-set!</span>)</span>
<span class="comment">;;#{"2" "3" "4"}</span></code></pre>
<h3 id='executors/first-into-map'>first-into-map!</h3 id='executors/first-into-map'>
<p>Gets the first object of the returned list and puts it into a set. 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
          q/map
          q/first-into-map</span>)</span>
<span class="comment">;;{:name "marko", :age 29}</span></code></pre>
<h3 id='executors/all-into-vecs'>all-into-vecs!</h3 id='executors/all-into-vecs'>
<p>Gets the list of returned objects and maps vec across all of the
objects.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         <span class="list">(<span class="title">q/path</span><span class="body"> <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:age</span></span>)</span>
                 <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:name</span></span>)</span></span>)</span>
         q/all-into-vecs!</span>)</span>
<span class="comment">;;([29 "vadas"] [29 "josh"] [29 "lop"])</span></code></pre>
<h3 id='executors/all-into-sets'>all-into-sets!</h3 id='executors/all-into-sets'>
<p>Gets the list of returned objects and maps set across all of the
objects.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         <span class="list">(<span class="title">q/path</span><span class="body"> <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:age</span></span>)</span>
                 <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:name</span></span>)</span></span>)</span>
         q/all-into-sets!</span>)</span>
<span class="comment">;;(#{"vadas" 29} #{"josh" 29} #{"lop" 29})</span></code></pre>
<h3 id='executors/all-into-maps'>all-into-maps!</h3 id='executors/all-into-maps'>
<p>Gets the list of returned objects and maps set across all of the
objects.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/&lt;->
         q/&lt;->
         q/map
         q/all-into-maps!</span>)</span>
<span class="comment">;; ({:name "marko", :age 29} </span>
<span class="comment">;;  {:name "marko", :age 29} </span>
<span class="comment">;;  {:name "ripple", :lang "java"} </span>
<span class="comment">;;  {:name "lop", :lang "java"} </span>
<span class="comment">;;  {:name "marko", :age 29} </span>
<span class="comment">;;  {:name "josh", :age 32} </span>
<span class="comment">;;  {:name "peter", :age 35})</span></code></pre>
<hr>
<h2 id='reduce'>Reduce</h2 id='reduce'>
<p>These functions sort of act like <code>clojure.core/reduce</code>.

</p>
<h3 id='reduce/order'>order</h3 id='reduce/order'>
<p>Order the items in the stream according to the provided function. If no
function is provided, then a default sort order is used.

</p>
<pre><code class="clojure">(q/query (g/get-vertices)
         (q/property :name)
         q/into-<span class="keyword">vec</span>!)                         
;;[<span class="string">"lop"</span> <span class="string">"vadas"</span> <span class="string">"marko"</span> <span class="string">"peter"</span> <span class="string">"ripple"</span> <span class="string">"josh"</span>]

(q/query (g/get-vertices)
         (q/property :name)
         q/order
         q/into-<span class="keyword">vec</span>!)                         
;;[<span class="string">"josh"</span> <span class="string">"lop"</span> <span class="string">"marko"</span> <span class="string">"peter"</span> <span class="string">"ripple"</span> <span class="string">"vadas"</span>]         

(q/query (g/get-vertices)
         (q/property :name)
         (q/order (<span class="function"><span class="keyword">fn</span> [<span class="title">a</span> <span class="title">b</span>] (</span>compare b a)))
         q/into-<span class="keyword">vec</span>!)                         
[<span class="string">"vadas"</span> <span class="string">"ripple"</span> <span class="string">"peter"</span> <span class="string">"marko"</span> <span class="string">"lop"</span> <span class="string">"josh"</span>]</code></pre>
<h3 id='reduce/gather'>gather</h3 id='reduce/gather'>
<p>Collect all objects up to that step and process the gathered list with
the provided closure.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         q/id
         q/gather
         q/first-into-vec!</span>)</span>
<span class="comment">;;["2" "3" "4"]         </span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         q/id
         <span class="list">(<span class="title">q/gather</span><span class="body"> count</span>)</span>
         q/into-vec!</span>)</span>
<span class="comment">;;3</span></code></pre>
<hr>
<h2 id='filter'>Filter</h2 id='filter'>
<p>Filter steps decide whether to allow an object to pass to the next
step or not.

</p>
<h3 id='filter/range'>range</h3 id='filter/range'>
<p>A range filter that emits the objects within a range.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"></span>)</span>
         <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[2]> #&lt;TinkerVertex v[4]> #&lt;TinkerVertex v[3]>]         </span>


<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"></span>)</span>
         <span class="list">(<span class="title">q/range</span><span class="body"> <span class="number">0</span> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[2]> #&lt;TinkerVertex v[4]>]</span></code></pre>
<h3 id='filter/dedup'>dedup</h3 id='filter/dedup'>
<p>Filter out repeated objects. A function can be supplied that provides
the values that the pipeline will consider when filtering 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/get-vertices</span><span class="body"></span>)</span>
         q/&lt;->
         <span class="list">(<span class="title">q/property</span><span class="body"> <span class="keyword">:name</span></span>)</span>
         <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>         
<span class="comment">;;["marko" "josh" "peter" "marko" "vadas" "josh" "lop" "lop" "josh" "marko" "ripple" "lop"]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/get-vertices</span><span class="body"></span>)</span>
         q/&lt;->
         q/dedup
         <span class="list">(<span class="title">q/property</span><span class="body"> <span class="keyword">:name</span></span>)</span>
         <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>
<span class="comment">;;["marko" "josh" "peter" "vadas" "lop" "ripple"]                         </span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/get-vertices</span><span class="body"></span>)</span>
          q/&lt;->
          <span class="list">(<span class="title">q/dedup</span><span class="body"> <span class="list">(<span class="title">partial</span><span class="body"> g/get-property <span class="keyword">:lang</span></span>)</span></span>)</span>
          <span class="list">(<span class="title">q/property</span><span class="body"> <span class="keyword">:name</span></span>)</span>
          <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>
<span class="comment">;;["marko" "lop"]</span></code></pre>
<p><code>g/get-vertices</code> retrieves all of the vertices of the graph and
provides them in a list. 

</p>
<h3 id='filter/except'>except</h3 id='filter/except'>
<p>Filter out the provided objects.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->
         q/&lt;--
         <span class="list">(<span class="title">q/except</span><span class="body"> [<span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>]</span>)</span>
         <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>         
<span class="comment">;;[#&lt;TinkerVertex v[4]> #&lt;TinkerVertex v[6]>]</span></code></pre>
<h3 id='filter/filter'>filter</h3 id='filter/filter'>
<p>Decide whether to allow an object to pass. Return true from the
closure to allow an object to pass.


</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/get-vertices</span><span class="body"></span>)</span>
         <span class="list">(<span class="title">q/filter</span><span class="body"> <span class="list">(<span class="title">fn</span><span class="body"> [v] <span class="list">(<span class="title">=</span><span class="body"> <span class="string">"java"</span> <span class="list">(<span class="body">.getProperty v <span class="string">"lang"</span></span>)</span></span>)</span></span>)</span></span>)</span>
         q/map
         <span class="list">(<span class="title">q/all-into-maps</span><span class="body">!</span>)</span></span>)</span>         
<span class="comment">;;({:name "lop", :lang "java"} {:name "ripple", :lang "java"})</span></code></pre>
<h3 id='filter/has'>has</h3 id='filter/has'>
<p>Allows an element if it has a particular property. The standard
Clojure operations for comparisons can also be supplied:
<code>&gt;</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>=</code>,<code>not=</code>.

</p>
<pre><code class="clojure">(q/query (g/get-vertices)
         (q/has :name "marko")                    
         (q/into-vec!))
;;[#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span>]         

(q/query (g/get-vertices)
         (q/has :age > (int 30))                    
         (q/into-vec!))
[#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">6</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span>]</code></pre>
<h3 id='filter/has-not'>has-not</h3 id='filter/has-not'>
<p>Allows an element if it does not have a particular property. 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/get-vertices</span><span class="body"></span>)</span>
         <span class="list">(<span class="title">q/has-not</span><span class="body"> <span class="keyword">:name</span> <span class="string">"marko"</span></span>)</span>                    
         <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[3]> #&lt;TinkerVertex v[2]> </span>
<span class="comment">;; #&lt;TinkerVertex v[6]> #&lt;TinkerVertex v[5]> </span>
<span class="comment">;; #&lt;TinkerVertex v[4]>]</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/get-vertices</span><span class="body"></span>)</span>
         <span class="list">(<span class="title">q/has-not</span><span class="body"> <span class="keyword">:age</span> > <span class="list">(<span class="title">int</span><span class="body"> <span class="number">30</span></span>)</span></span>)</span>                    
         <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[2]> #&lt;TinkerVertex v[1]>]</span></code></pre>
<h3 id='filter/interval'>interval</h3 id='filter/interval'>
<p>Allow elements to pass that have their property in the provided start
and end interval.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/--E></span><span class="body"></span>)</span>
         <span class="list">(<span class="title">q/interval</span><span class="body"> <span class="keyword">:weight</span> <span class="number">0</span> <span class="number">0.6</span></span>)</span>
         <span class="list">(<span class="title">q/in-vertex</span><span class="body"></span>)</span>
         <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[2]> #&lt;TinkerVertex v[3]>]</span></code></pre>
<h3 id='filter/random'>random</h3 id='filter/random'>
<p>Emits the incoming objects, each with the supplied chance.

</p>
<pre><code class="clojure">;; Results will vary
(q/query (g/get-vertices)
         (q/random 0.5)
         (q/into-vec!))
[#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">6</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span>]

(q/query (g/get-vertices)
         (q/random 0.5)
         (q/into-vec!))
;; Results will vary
[#<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">3</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">1</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">6</span>]></span> #<span class="tag">&lt;<span class="title">TinkerVertex</span> <span class="attribute">v</span>[<span class="attribute">4</span>]></span>]</code></pre>
<h3 id='filter/retain'>retain</h3 id='filter/retain'>
<p>Allow everything to pass except what is not in the supplied
collection.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"></span>)</span>      
         <span class="list">(<span class="title">q/retain</span><span class="body"> [<span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">2</span></span>)</span>]</span>)</span>
         <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[2]>]</span></code></pre>
<h2 id='annotations'>Annotations</h2 id='annotations'>
<p>So far, we&#39;ve had great success traversing the graph. If you&#39;ve
understood most of everything up to this point, you know how to do
sorts of neat things with graphs. There&#39;s another level of traversal
that we can attain though. We can annotate and traverse the pipeline
itself, which lets us do all sorts of fancy tricks. 


</p>
<h3 id='annotations/back'>back</h3 id='annotations/back'>
<p>Go back to the results from n-steps ago.

</p>
<pre><code><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         q/-->      
         <span class="list">(<span class="title">q/back</span><span class="body"> <span class="number">1</span></span>)</span> 
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[1]>]</span></code></pre>
<h3 id='annotations/as-back-to'>as/back-to</h3 id='annotations/as-back-to'>
<p><code>as</code> lets you name a step that you can later return to with <code>back-to</code>. 

</p>
<pre><code><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"here"</span></span>)</span>
         q/-->      
         <span class="list">(<span class="title">q/back-to</span><span class="body"> <span class="string">"here"</span></span>)</span>         
         q/into-vec!</span>)</span>
<span class="comment">;;[#&lt;TinkerVertex v[1]>]</span></code></pre>
<h3 id='annotations/select'>select</h3 id='annotations/select'>
<p>Get a list of named steps, with optional functions for post processing
round robin style. (This will be returned as a map when Pipes is
upgraded to 2.3.0).

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"a"</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"> <span class="keyword">:knows</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"b"</span></span>)</span>
         q/select
         q/all-into-vecs!</span>)</span>
<span class="comment">;;([#&lt;TinkerVertex v[1]> #&lt;TinkerVertex v[2]>] </span>
<span class="comment">;; [#&lt;TinkerVertex v[1]> #&lt;TinkerVertex v[4]>])         </span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"a"</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"> <span class="keyword">:knows</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"b"</span></span>)</span>
         <span class="list">(<span class="title">q/select</span><span class="body"> <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:name</span></span>)</span></span>)</span>
         q/all-into-vecs!</span>)</span>
<span class="comment">;;(["marko" "vadas"] ["marko" "josh"])</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"a"</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"> <span class="keyword">:knows</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"b"</span></span>)</span>
         <span class="list">(<span class="title">q/select</span><span class="body"> <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:name</span></span>)</span> g/get-id</span>)</span>
         q/all-into-vecs!</span>)</span>
<span class="comment">;;(["marko" "2"] ["marko" "4"])</span></code></pre>
<h3 id='annotations/select-only'>select-only</h3 id='annotations/select-only'>
<p>Select the named steps to emit, with round robin style function
processing again. 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"a"</span></span>)</span>
         q/-->
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"b"</span></span>)</span>
         q/-->
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"c"</span></span>)</span>       
         <span class="list">(<span class="title">q/select-only</span><span class="body"> [<span class="string">"a"</span> <span class="string">"b"</span>]</span>)</span>
         q/all-into-vecs!</span>)</span>
<span class="comment">;;([#&lt;TinkerVertex v[1]> #&lt;TinkerVertex v[4]>] </span>
<span class="comment">;; [#&lt;TinkerVertex v[1]> #&lt;TinkerVertex v[4]>])</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"a"</span></span>)</span>
         q/-->
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"b"</span></span>)</span>
         q/-->
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"c"</span></span>)</span>       
         <span class="list">(<span class="title">q/select-only</span><span class="body"> [<span class="string">"a"</span> <span class="string">"c"</span>] <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:name</span></span>)</span></span>)</span>
         q/all-into-vecs!</span>)</span>
<span class="comment">;;(["marko" "ripple"] ["marko" "lop"])</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"a"</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"> <span class="keyword">:knows</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"b"</span></span>)</span>
         q/-->
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"c"</span></span>)</span>                
         <span class="list">(<span class="title">q/select-only</span><span class="body"> [<span class="string">"a"</span> <span class="string">"c"</span>] <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:name</span></span>)</span> g/get-id</span>)</span>
         q/all-into-vecs!</span>)</span>
<span class="comment">;;(["marko" "5"] ["marko" "3"])</span></code></pre>
<h3 id='annotations/loop'>loop</h3 id='annotations/loop'>
<p>Loop over a particular set of steps in the pipeline. The first
argument is the number of steps back. The second argument is a
predicate that takes three objects: the current object, the current
path, and the number of loops thus far. While the predicate evaluates
true, the loop continues on it&#39;s merry way. 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"></span>)</span>
         <span class="list">(<span class="title">q/loop</span><span class="body"> <span class="number">1</span>
                 <span class="list">(<span class="title">fn</span><span class="body"> [l o p] <span class="list">(<span class="title">&lt;</span><span class="body"> l <span class="number">3</span></span>)</span></span>)</span></span>)</span>
         <span class="list">(<span class="title">q/property</span><span class="body"> <span class="keyword">:name</span></span>)</span>
         <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>                           
<span class="comment">;;["ripple" "lop"]</span></code></pre>
<h3 id='annotations/loop-to'>loop-to</h3 id='annotations/loop-to'>
<p><code>loop-to</code> is just like loop, but it travels back to a named step
instead. 

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/find-by-id</span><span class="body"> <span class="number">1</span></span>)</span>
         <span class="list">(<span class="title">q/as</span><span class="body"> <span class="string">"here"</span></span>)</span>
         <span class="list">(<span class="title">q/--></span><span class="body"></span>)</span>
         <span class="list">(<span class="title">q/loop-to</span><span class="body"> <span class="string">"here"</span>
                 <span class="list">(<span class="title">fn</span><span class="body"> [l o p] <span class="list">(<span class="title">&lt;</span><span class="body"> l <span class="number">3</span></span>)</span></span>)</span></span>)</span>
         <span class="list">(<span class="title">q/property</span><span class="body"> <span class="keyword">:name</span></span>)</span>
         <span class="list">(<span class="title">q/into-vec</span><span class="body">!</span>)</span></span>)</span>                           
<span class="comment">;;["ripple" "lop"]</span></code></pre>
<hr>
<h2 id='side-effect'>Side Effect</h2 id='side-effect'>
<p>As this stage in Ogre&#39;s development, side effect steps immediately
return various data structures about the query. 

</p>
<h3 id='side-effect/get-grouped-by'>get-grouped-by</h3 id='side-effect/get-grouped-by'>
<p>Takes in a key function and processing function. Returns all of the
processed objects grouped by the value of the key function.

</p>
<pre><code class="clojure"><span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/get-vertices</span><span class="body"></span>)</span>
         <span class="list">(<span class="title">q/get-grouped-by</span><span class="body">! <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:lang</span></span>)</span>
                            identity</span>)</span></span>)</span>
<span class="comment">;;{nil [#&lt;TinkerVertex v[2]> #&lt;TinkerVertex v[1]> </span>
<span class="comment">;;      #&lt;TinkerVertex v[6]> #&lt;TinkerVertex v[4]>], </span>
<span class="comment">;;"java" [#&lt;TinkerVertex v[3]> #&lt;TinkerVertex v[5]>]}</span>

<span class="list">(<span class="title">q/query</span><span class="body"> <span class="list">(<span class="title">g/get-vertices</span><span class="body"></span>)</span>
         <span class="list">(<span class="title">q/get-grouped-by</span><span class="body">! <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:lang</span></span>)</span>
                            <span class="list">(<span class="title">q/prop</span><span class="body"> <span class="keyword">:name</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;;{nil ["vadas" "marko" "peter" "josh"], "java" ["lop" "ripple"]}</span></code></pre>
<h3 id='side-effect/get-group-count'>get-group-count</h3 id='side-effect/get-group-count'>
<p>Emits input, but updates a map for each input, where closures provides
generic map update.

</p>
<h3 id='side-effect/get-table'>get-table</h3 id='side-effect/get-table'>
<p>Emits input, but stores row of as values (constrained by column names
if provided) in a table. Accepts an optional set of closures that are
applied in round-robin fashion to each column of the table.

</p>
<h3 id='side-effect/get-tree'>get-tree</h3 id='side-effect/get-tree'>
<p>Emit input, but stores the tree formed by the traversal as a map.
Accepts an optional set of closures to be applied in round-robin
fashion over each level of the tree.

</p>
<h3 id='side-effect/side-effect'>side-effect</h3 id='side-effect/side-effect'>
<p>Emits input, but calls a side effect closure on each input.

</p>
<hr>
<h2 id='branch'>Branch</h2 id='branch'>
<p>Branch steps decide which step to take.

</p>
<h3 id='branch/copy-split'>copy-split</h3 id='branch/copy-split'>
<p>Copies incoming object to internal pipes.

</p>
<h3 id='branch/exhaust-merge'>exhaust-merge</h3 id='branch/exhaust-merge'>
<p>Used in combination with a <code>copySplit</code>, merging the parallel
traversals by exhaustively getting the objects of the first, then the
second, etc.

</p>
<h3 id='branch/fair-merge'>fair-merge</h3 id='branch/fair-merge'>
<p>Used in combination with a <code>copySplit</code>, merging the parallel
traversals in a round-robin fashion.

</p>
<h3 id='branch/if-then-else'>if-then-else</h3 id='branch/if-then-else'>
<p>Allows for if-then-else conditional logic.

</p>
<h3 id='branch/memoize'>memoize</h3 id='branch/memoize'>
<p>Remembers a particular mapping from input to output. Long or expensive
expressions with no side effects can use this step to remember a
mapping, which helps reduce load when previously processed objects are
passed into it.

</p>
<p>For situations where memoization may consume large amounts of RAM,
consider using an embedded key-value store like
<a href="http://code.google.com/p/jdbm2/">JDBM</a> or some other persistent Map
implementation.

</p>
<hr>
<h2 id='recipes'>Recipes</h2 id='recipes'>
<p>Recipes are common patterns that are seen in using Gremlin.

</p>
<h3 id='recipes/duplicate-edges'>Duplicate Edges</h3 id='recipes/duplicate-edges'>
<p>Strictly speaking, you cannot have duplicated egdes with the same id.
This example finds edges with same <code>outV/inV/label</code> properties.

</p>
<h3 id='recipes/paging-results'>Paging Results</h3 id='recipes/paging-results'>
<p>It is sometimes desireable to not return an entire results set.
Results can be paged or limited as follows:

</p>
<h3 id='recipes/paths-between-two-vertices'>Paths Between Two Vertices</h3 id='recipes/paths-between-two-vertices'>
<p>First, paths for a directed graph:

</p>
<p>Then, undirected:

</p>
<p>Use the value of <code>it.loops&lt;=3</code>to control the depth of the traversal:

</p>
<h3 id='recipes/reading-from-a-file'>Reading From a File</h3 id='recipes/reading-from-a-file'>
<p>Reading data from an edge file formatted as CSV is easy to do with
Gremlin.

</p>
<h3 id='recipes/sampling'>Sampling</h3 id='recipes/sampling'>
<p>It is sometimes useful to grab a random sample of the items in a
collection. That can be done to some degree with the
<a href="#filter.random">random</a> step, but getting an explicit number of items
is not supported using that step.

</p>
<h3 id='recipes/shortest-path'>Shortest Path</h3 id='recipes/shortest-path'>
<p>Find the shortest path between two vertices:
</p>

  </div>
</div></body>
</html>